## 01. Лямбда-выражения и функциональные интерфейсы
* Оказывается, что в ОЗУ сохраняются не только переменные, но и методы.
* Это значит (то что методы тоже лежат в памяти), что на них можно делать ссылки.
* Чтобы получить метод как значение, которое можно записать в переменную, нужно указать имя класса, а потом 
оператор разрешения областей видимости (::) (scope resolution operator).
* Это значение будет называться ссылкой на метод (method reference).
* Это значение теперь можно записать в переменную.
* Тип переменной, в которую можно записать эту ссылку будет функциональным интерфейсом
* Функциональный интерфейс - это такой интерфейс, у которого есть всего один не реализованный метод, и он (интерфейс)
аннотирован как @FunctionalInterface
* Для методов с разными конфигурациями возвращаемых значений и параметров существуют разные функциональные интерфейсы.
* Например, для методов которые ничего не принимают и ничего не возвращают используется Runnable

* Лямбда-выражения (ЛВ) - они же анонимные функции - это такие методы, которые определены внутри выполняемых блоков кода.
* ЛВ не могут существовать сами по себе, они обязательно должны быть записаны в переменную типа функционального интерфейса.
* ЛВ выполняются не при определении, а при вызове из переменной.
* Так как ЛВ можно передавать как переменные в другие методы, это, по сути, является способом передавать недостающие
куски кода в другие методы.
* Синтаксис:
```
(параметры) -> {выполняемый код}
```
* Обратите внимание, что "->" это два символа, "тире" и "знак больше"

* Основные функциональные интерфейсы в Java:
  * Runnable - ЛВ которые не возвращают и не принимают ничего
  * Supplier - ЛВ которые ничего не принимают, но что-то возвращают
  * Consumer - ЛВ которые что-то принимают, но ничего не возвращают
  * Function - ЛВ которые принимают один параметр, и что-то возвращают
  * Predicate - ЛВ которые принимают один параметр и возвращают boolean
  * Comparator - ЛВ которое принимает два параметра и сравнивает их. Возвращает 1, 0 или -1 в зависимости 
  от результата сравнения. 1 если первый объект больше второго, 0 если они равны, -1 если второй больше первого

## 02. Stream API
* API - Application programming interface - такой набор классов, который позволяет вам взаимодействовать с чем-то.
* StreamAPI - Библиотека в джаве, которая позволяет очень быстро и удобно обрабатывать данные.
* Эта библиотека может заменить десятки строк на одну инструкцию.
* Основным классом является Stream - поток объектов.
* В этом потоке объектов, над ними можно делать различные манипуляции:

* Создание:
  * .stream() у любой коллекции - создает поток и ложит в него все элементы коллекции.
  * Stream.of() - Создает поток из всех элементов, которые будут сюда переданы.
  * Arrays.stream() - Создает поток и добавляет в него все элементы переданного массива.
* Обработка данных (промежуточные операции, intermidiate operations):
  * filter - принимает предикат, удаляет все элементы из потока, которые не подходят (предикат для них вернул false).
  * limit - принимает число и ограничивает количество элементов потока до этого числа (обрезает).
  * map - принимает функцию, которая преобразовывает один объект в другой. Таким образом можно поменять обобщенный тип потока.
  * distinct - удаляет все дубликаты.
  * sorted - сортирует поток по натуральному порядку, либо по предоставленному компаратору.
  * skip - принимает число и удаляет такое количетсво элементов с начала.
  * dropWhile - принимает предикат, и удаляет с начала все элементы, пока для них преди
  * peek - принимает потребителя (Consumer) и выполняет его на каждом элементе.
  * flatMap - "уравнивает" поток из коллекций, так, чтобы после этого в потоке были только элементы самих коллекций
* Сбор данных (терминальные операции, terminal operations):
  * count - возвращет количество элементов в потоке, на котором он был вызван
  * forEach - делает тоже самое что и peek, только при этом завершает работу потока (возвращает void).
  * reduce - уменьшает весь поток до одного элемента, правило уменьшения задается переданной функцией
  * anyMatch - возвращает true, если хотябы один элемент совпадает с переданным предикатом
  * allMatch - возвращает true, если все элементы дают true с переданным предикатом
  * noneMatch - возвращает true, если все элементы дают false с переданным предикатом
  * max/min - возвращает максимальное/минимальное значение (по переданному компаратору)
  * collect - принимает коллектор, возвращает поток как коллекцию
  * toList - возвращает поток как обычный список (с 16 версии джавы)

* Задачи:
  * Подсчитать отрицательные числа в массиве
  * Подсчитать сколько раз слово встречается в списке строк
  * Напечатать "Хеш-таблицу"
  * Превратить массив чисел в строку, разделенную запятыми
  * Проверить, будут ли все строки в списке больше 10 символов в длинну
  * Из списка чисел получить пять самых больших чисел
  * Из строки сделать аббревиатуру